<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="ru">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Почему я выбираю Storm ORM для Python &mdash; @emacsway&#39;s blog</title>
    
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/jquery-toast-plugin/jquery.toast.min.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/jquery-toast-plugin/jquery.toast.min.js"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="author" title="About these documents" href="../../about/" />
    <link rel="top" title="@emacsway&#39;s blog" href="../../" />
  

   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />


    

        <meta http-equiv="Last-Modified" content="Mon, 31 Jul 2017 00:00:00 GMT" />
        
            <meta name="description" content="В промышленных решениях на Python я чаще стал использовать KISS-style Storm ORM, и здесь я попытаюсь объяснить почему." />
        
        
            <meta property="og:image" content="../../_static/logo.jpg" />
            <link rel="image_src" href="../../_static/logo.jpg" />
        

        <link rel="canonical" href="https://emacsway.github.io/ru/storm-orm/" />

        <script type="text/javascript">
            setTimeout(function() {
                $.toast({
                    text: 'If you like this site, please support it with an external link or share it with an social nerwork. Thanks!',
                    position: 'bottom-right',
                    hideAfter: 7000
                });
            }, 30000);
        </script>

    


  
  <link rel="alternate" type="application/atom+xml"  href="../../blog/atom.xml" title="@emacsway's blog">
  
  
  <link href="True" rel="stylesheet">
  
  <style type="text/css">
    ul.ablog-archive {list-style: none; overflow: auto; margin-left: 0px}
    ul.ablog-archive li {float: left; margin-right: 5px; font-size: 80%}
    ul.postlist a {font-style: italic;}
    ul.postlist-style-disc {list-style-type: disc;}
    ul.postlist-style-none {list-style-type: none;}
    ul.postlist-style-circle {list-style-type: circle;}
  </style>

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="storm-orm-python">
<h1><a class="toc-backref" href="#id40">Почему я выбираю Storm ORM для Python</a><a class="headerlink" href="#storm-orm-python" title="Permalink to this headline">¶</a></h1>
<p>В промышленных решениях на Python я чаще стал использовать <a class="reference external" href="https://en.wikipedia.org/wiki/KISS_principle">KISS-style</a> <a class="reference external" href="https://storm.canonical.com/">Storm ORM</a>, и здесь я попытаюсь объяснить почему.</p>
<div class="contents topic" id="id1">
<p class="topic-title first">Содержание</p>
<ul class="simple">
<li><a class="reference internal" href="#storm-orm-python" id="id40">Почему я выбираю Storm ORM для Python</a></li>
<li><a class="reference internal" href="#orm" id="id41">Мои критерии к ORM</a></li>
<li><a class="reference internal" href="#storm-orm-advantages-ru" id="id42">О достоинствах</a></li>
<li><a class="reference internal" href="#sqlalchemy" id="id43">По поводу SQLAlchemy</a></li>
<li><a class="reference internal" href="#storm-orm-disadvantages-ru" id="id44">О недостатках</a></li>
<li><a class="reference internal" href="#storm-orm-ambiguities-ru" id="id45">О неоднозначном</a></li>
<li><a class="reference internal" href="#faq" id="id46">FAQ</a></li>
<li><a class="reference internal" href="#why-orm-ru" id="id47">А нужен ли вообще ORM?</a><ul>
<li><a class="reference internal" href="#query-object" id="id48">Нужен ли Query Object?</a></li>
<li><a class="reference internal" href="#data-mapper" id="id49">Нужен ли сам Data Mapper?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id38" id="id50">Послесловие</a></li>
</ul>
</div>
</div>
<div class="section" id="orm">
<span id="orm-criteria-ru"></span><h1><a class="toc-backref" href="#id41">Мои критерии к ORM</a><a class="headerlink" href="#orm" title="Permalink to this headline">¶</a></h1>
<dl class="docutils">
<dt>Скорость</dt>
<dd>ORM должен быть быстрым.
ORM должен иметь <a class="reference external" href="http://martinfowler.com/eaaCatalog/identityMap.html">Identity Map</a> для предотвращения запросов в БД, если объект уже был загружен.
Этот момент особенно важен, когда различные изолированные компоненты приложения пытаются загрузить один и тот же объект из БД в собственную область видимости.
Кроме того, я считаю, что Identity Map должен конфигурироваться под уровни изоляции транзакции, чтобы, например, не повторять запросы в БД, если такого объекта не существует.</dd>
<dt>Простота</dt>
<dd>ORM не должен пугать своим видом в отладчике, а понять что он делает можно было не более чем из просмотра исходников.
Любой продукт рано или поздно умирает, или хотя бы теряет интерес к себе со стороны автора, поэтому всегда нужно быть готовым взять сопровождение выбранного продукта на себя.
Новые люди должны легко осваивать продукт.
А единственным источником истины о коде служит сам код.
Комментарии, документирование, конечно, облегчают осваивание продукта, но часто они освещают далеко не все, и нередко отстают от реального кода.
И я не встречал в своей практике ни одной библиотеки, которую не было бы необходимости адаптировать или расширять.
А в таких вопросах простота выходит на первый план.</dd>
<dt>Архитектура</dt>
<dd><p class="first">Грамотное разделение уровней абстракции, соблюдение базовых принципов архитектуры, таких как <a class="reference external" href="https://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29">SOLID</a>.</p>
<p>Если Вы не можете использовать отдельно взятый компонент ORM, например SQLBuilder, изолированно от всей системы, то, наверное, такой ORM лучше вообще не использовать (в пользу &#8220;низкоуровневых&#8221; паттернов обработки данных).
Хорошо спроектированный ORM позволяет использовать свои компоненты по отдельности, <a class="reference external" href="http://martinfowler.com/eaaCatalog/queryObject.html">Query Object</a> (SQLBuilder), Connection, <a class="reference external" href="http://martinfowler.com/eaaCatalog/dataMapper.html">DataMapper</a>, <a class="reference external" href="http://martinfowler.com/eaaCatalog/identityMap.html">Identity Map</a>, <a class="reference external" href="http://martinfowler.com/eaaCatalog/unitOfWork.html">Unit of Work</a>, <a class="reference external" href="http://martinfowler.com/eaaCatalog/repository.html">Repository</a>.
Можете ли Вы в своем ORM использовать Raw-SQL (полностью или частично)?
Можете ли Вы изолированно использовать только Data Mapper?
Можете ли Вы подменить Data Mapper, например, на <a class="reference external" href="http://martinfowler.com/eaaCatalog/serviceStub.html">фиктивную службу</a>, которая не будет осуществлять запросы в БД?</p>
<p>Возможности любого ORM приходится расширять.
Насколько легко расширить Ваш ORM без форков, патчей, манкипатчей? Соблюдается ли в нем <a class="reference external" href="https://en.wikipedia.org/wiki/Open/closed_principle">Open/Closed Principle</a> (OCP)?</p>
<blockquote class="last">
<div>&#8220;The primary occasion for using Data Mapper is when you want the database schema and the object model to evolve independently. The most common case for this is with a Domain Model (116). Data Mapper&#8217;s primary benefit is that when working on the domain model you can ignore the database, both in design and in the build and testing process. The domain objects have no idea what the database structure is, because all the correspondence is done by the mappers.&#8221;
(«Patterns of Enterprise Application Architecture» <a class="footnote-reference" href="#fnpoeaa" id="id2">[3]</a>)</div></blockquote>
</dd>
<dt><a class="reference external" href="https://en.wikipedia.org/wiki/ACID">ACID</a> и <a class="reference external" href="https://en.wikipedia.org/wiki/Two-phase_commit_protocol">Two-phase transaction</a></dt>
<dd>Хорошая система следит за соответствием объекта в памяти его записи в БД.
Представьте, что Вы загрузили объект, и затем сделали коммит.
На этот объект уже ссылаются десятки других объектов, но он был изменен в БД другим потоком.
Если после этого Вы приступите к изменению этого объекта, - то изменения, внесенные другим потоком будут утрачены.
В момент коммита Вам необходимо согласовать состояние объектов в памяти с данными на диске, и при этом сохранить все ссылки на них.
Смотрите также эту <a class="reference external" href="http://techspot.zzzeek.org/2012/11/14/pycon-canada-the-sqlalchemy-session-in-depth/">статью</a> и <a class="reference external" href="http://techspot.zzzeek.org/files/2012/session.key.pdf">презентацию</a>.
Для гарантирования целостности данных, одной только подержки транзакций приложением недостаточно.
Разумеется, это не критическое требование, однако без его выполнения невозможно полностью сокрыть источник данных в коде.</dd>
<dt>Сокрытие источника</dt>
<dd><p class="first">Хороший ORM позволяет Вам позабыть о своем существовании, и обращаться с объектами моделей так, будто это обычные объекты.
Он не будет раскрывать источник данных, требуя от Вас явного вызова метода для сохранения объектов.
Не будет вынуждать Вас &#8220;перезагружать&#8221; объекты.
Позволит легко подменить маппер, даже если Вы смените реляционную БД на нереляционную.</p>
<p>Представьте, что Вы создали два новых объекта, из которых один ссылается на другой по внешнему ключу.
Можете ли Вы создать между ними связь до того, как хотя бы один из них будет сохранен в БД и получит первичный ключ?
Обновится ли значение внешнего ключа связанного объекта в тот момент когда первый объект будет сохранен и получит первичный ключ?</p>
<p class="last">Хороший ORM предотвращает дедлоки, потому что сохраняет все объекты непосредственно перед коммитом, минимизируя интервал времени от первого сохранения до коммита.
Кроме того, он позволит Вам влиять на порядок сохранения объектов, например, используя топологическую сортировку для предотвращения дедлоков.</p>
</dd>
</dl>
</div>
<div class="section" id="storm-orm-advantages-ru">
<span id="id3"></span><h1><a class="toc-backref" href="#id42">О достоинствах</a><a class="headerlink" href="#storm-orm-advantages-ru" title="Permalink to this headline">¶</a></h1>
<p>Несмотря на номер релиза, - код достаточно стабилен.
Удачная архитектура в сочетании с <a class="reference external" href="https://en.wikipedia.org/wiki/KISS_principle">принципом KISS</a> создает ложную иллюзию, что Storm ORM якобы не развивается.
Это не так.
На самом деле, там просто нечего развивать.
За три года копания в исходниках Storm ORM я не нашел ничего, что можно было бы улучшить.
Расширить - да, можно.
Но не изменить.
<a class="reference external" href="https://code.launchpad.net/storm">Коммиты происходят регулярно</a>.
Но их можно охарактеризовать как &#8220;вылизывание&#8221;, или &#8220;полирование&#8221;.</p>
<p>Storm ORM поддерживает композитные ключи и связи (после Django Models я облегченно вздохнул).</p>
<p>Позволяет выражать SQL-запросы практически любой сложности (по крайней мере, конструктивно).</p>
<p>Работает с любым количеством БД.</p>
<p>Реализует <a class="reference external" href="http://martinfowler.com/eaaCatalog/dataMapper.html">DataMapper</a> pattern, а значит классы моделей свободны от метаданных и логики доступа к БД, как это свойственно для <a class="reference external" href="http://www.martinfowler.com/eaaCatalog/activeRecord.html">ActiveRecord</a>.
Классы моделей могут наследоваться от простого класса <a class="reference external" href="https://docs.python.org/2/library/functions.html#object">object</a>.</p>
<p>Благодаря <a class="reference external" href="http://martinfowler.com/eaaCatalog/identityMap.html">Identity Map</a>, <a class="reference external" href="https://storm.canonical.com/">Storm ORM</a> очень быстр.
На странице одного из проектов, после внедрения Storm ORM (вместо Django ORM), затраты на работу ORM упали с 0.21 сек до 0.014 сек, т.е. в 15 раз, а совокупное время генерации страницы сократилось в два раза, с 0.48 сек до 0.24 сек.
Количество запросов в БД сократилось с 88 до 7.
Identity Map также делает ненужными утилиты типа prefetch_related(), правда только для внешних ключей ссылающихся на первичный ключ.</p>
<p>Работать с кодом Storm ORM приятно.
Можно найти много интересных методик по оптимизации кода.
Нужно отдать должное разработчикам Storm ORM, - они совершили настоящий умственный подвиг.
Весь код тщательно продуман.
Любые попытки его улучшить обычно только убеждают в правильности существующего решения.</p>
<p>Storm ORM очень грамотно обрабатывает транзакции.
Здесь нельзя встретить бездумный реконнект в случае обрыва соединения во время незавершенной транзакции.
Соединение восстановится только в том случае, если это не может отразиться на целостности данных.
Сами транзакции сделаны двухуровневыми.
В случае rollback откатывается также состояние объектов в памяти.</p>
<p>Благодаря наличию у Storm ORM возможности скомпилировать критерии выборки в коллекцию фильтров Python-кода, применимых к любой коллекции объектов в памяти, Storm ORM предоставляет неплохие возможности для создания фиктивного маппера для тестов.
А для выборки объектов из <code class="docutils literal"><span class="pre">Store()</span></code> по первичному ключу (в том числе и посредством вызова Foreign Key) и создавать вообще ничего не нужно, так как благодаря паттерну Identity Map можно просто не посылать объекты в БД, и использовать реальный маппер как фиктивный.</p>
<p>Storm ORM не производит конвертации значений сразу, в момент загрузки объекта.
Вместо этого он просто заворачивает значение во враппер (адаптер) - класс Variable.</p>
<p>Это позволяет:</p>
<ul class="simple">
<li>Контролировать политику присваивания и доступа.</li>
<li>Оптимизировать ресурсы (конвертация не производится до фактической востребованности).</li>
<li>Сохранять первоначальное значение атрибута, следить за его изменениями, реализовывать откат (rollback) на уровне объектов языка программирования.</li>
<li>Наблюдать за изменениями значения (обсервер) и обновлять связанные объекты.</li>
<li>Синхронизировать значение объекта со значением на диске.</li>
<li>Предотвратить присваивание невалидного значения. Что, кроме следования базовым принципам ООП, также устраняет проблему &#8220;G22: Make Logical Dependencies Physical&#8221; <a class="footnote-reference" href="#fncc" id="id4">[1]</a> и &#8220;G31: Hidden Temporal Couplings&#8221; <a class="footnote-reference" href="#fncc" id="id5">[1]</a>, которая обычно заключается в сохранении объекта с забыванием его провалидировать.</li>
<li>Валидировать значение только при присваивании его извне, но не из БД. Это исключает проблему невозможности пересохранения данных в случае изменения правил валидации.</li>
<li>Конвертировать значение в нужное представление в зависимости от контекста использования (Python или DB).</li>
</ul>
<p>С последним, правда, тоже есть некоторые нюансы.</p>
<p>Например, мы добавляем критерий выборки:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">GeoObjectModel</span><span class="o">.</span><span class="n">point</span> <span class="o">==</span> <span class="n">author_instance</span><span class="o">.</span><span class="n">location</span><span class="p">)</span>
</pre></div>
</div>
<p>Конвертор какого атрибута здесь должен работать, <code class="docutils literal"><span class="pre">GeoObjectModel.point</span></code> или <code class="docutils literal"><span class="pre">AuthorModel.location</span></code>?
Очевидно что <code class="docutils literal"><span class="pre">AuthorModel.location</span></code>, так как именно он предоставляет значение.
Но работать будет <code class="docutils literal"><span class="pre">GeoObjectModel.point</span></code>.
Что если эти конверторы имеют различное поведение?
И что произойдет если мы передадим такой критерий: <code class="docutils literal"><span class="pre">Func('SOME_FUNCTION_NAME',</span> <span class="pre">AuthorModel.location)</span></code>?</p>
<p>Справедливости ради нужно сказать, что Storm ORM сделал большой прорыв по упорядочиванию данного аспекта, по сравнению большинством других ORM, и заложил правильный фундамент для построения идеальной конвертации.
При соблюдении несложных правил конверторы будут работать идеально правильно (для этого в критерии выборки нужно передавать <a class="reference external" href="http://bazaar.launchpad.net/~storm/storm/trunk/view/477/storm/store.py#L597">инстанцию Variable()</a>, т.е. &#8220;завернутое&#8221; значение).
В то время как во многих других ORM такая возможность технически отсутствует из-за того, что конвертации делаются в момент создания объекта.
Иными словами, там конверторы фактически привязываются к типу значения а не к конкретному атрибуту (как это декларируется), что делает их практически бесполезными, учитывая что эти функции итак <a class="reference external" href="http://initd.org/psycopg/docs/advanced.html#adapting-new-python-types-to-sql-syntax">возложены на коннектор</a>.</p>
<p>Storm ORM не навязывает способ получения коннекта.
Вы <a class="reference external" href="http://bazaar.launchpad.net/~storm/storm/trunk/view/477/storm/database.py#L502">легко можете</a> расшарить коннект между двумя ORM или использовать какой-то <a class="reference external" href="http://eventlet.net/doc/modules/db_pool.html">особый способ</a> получения коннекта.</p>
<p>Storm ORM <a class="reference external" href="https://lists.ubuntu.com/archives/storm/2009-June/001010.html">не обязывает</a> декларировать схему БД в коде.
Это соответствует принципу <a class="reference external" href="https://en.wikipedia.org/wiki/Don't_repeat_yourself">DRY</a>, - схема уже есть в БД.
Кроме того, полный контроль над схемой БД <a class="reference external" href="https://blogs.gnome.org/jamesh/2007/09/28/orm-schema-generation/">легче всего достигнуть средствами самой БД</a>.
Обычно в крупных проектах, использующих репликацию и шардинг, используются собственные инструменты для контроля за схемой.
Как вариант, можно воспользоваться поставляемым вместе со Storm ORM пакетом <a class="reference external" href="http://bazaar.launchpad.net/~storm/storm/trunk/files/477/storm/schema/">storm.schema</a>.
<a class="reference external" href="http://docs.sqlalchemy.org/en/rel_1_1/core/reflection.html">В отличии от SQLAlchemy</a>, в Storm ORM не предусмотрена и автоматическая подгрузка незадекларированных свойств модели из БД.
При желании это несложно реализовать, но обращаться к БД придется на стадии инициализации кода, а неявность кода затруднит его визуальное восприятие (просмотра исходников будет недостаточно для получения представления о моделях).
Кроме того, различные типы данных в Python могут иметь один и тот же тип данных в БД, а значит, данных БД для полноценной декларации классов недостаточно.</p>
<p>Другие достоинства хорошо отражены в <a class="reference external" href="https://storm.canonical.com/Tutorial">Tutorial</a> и в <a class="reference external" href="https://storm.canonical.com/Manual">Manual</a></p>
</div>
<div class="section" id="sqlalchemy">
<span id="about-sqlalchemy-ru"></span><h1><a class="toc-backref" href="#id43">По поводу SQLAlchemy</a><a class="headerlink" href="#sqlalchemy" title="Permalink to this headline">¶</a></h1>
<p>В общем-то любой <a class="reference external" href="http://aosabook.org/en/sqlalchemy.html">ORM хорош</a>, если он <a class="reference external" href="http://techspot.zzzeek.org/2012/02/07/patterns-implemented-by-sqlalchemy/">реализует принципы</a> нашумевшей книги «Patterns of Enterprise Application Architecture» <a class="footnote-reference" href="#fnpoeaa" id="id6">[3]</a>.
Storm ORM контрастирует своей простотой на фоне SQLAlchemy также, как VIM на фоне Emacs, или jQuery на фоне Dojo.
Идеологически между ними много общего, я бы даже сказал, что Storm ORM - это упрощенная версия SQLAlchemy.
Исходники Storm ORM изучаются быстрее, нежели вводный tutorial SQLAlchemy.
Раширяется и адаптируется Storm ORM быстрее, чем приходит понимание того, как это можно сделать под SQLAlchemy.</p>
<p>Но существует грань, которая делает SQLAlchemy более предпочтительной, чем Storm ORM.
Если функционал Storm ORM Вас устраивает, Вы &#8220;владеете пером&#8221;, и располагаете временем на адаптацию библиотеки под свои нужды, то Storm ORM выглядит привлекательней.
В противном случае, SQLAlchemy становится предпочтительней, даже невзирая на уровень ее сложности, поскольку многие решения предоставляет &#8220;из коробки&#8221;.</p>
</div>
<div class="section" id="storm-orm-disadvantages-ru">
<span id="id7"></span><h1><a class="toc-backref" href="#id44">О недостатках</a><a class="headerlink" href="#storm-orm-disadvantages-ru" title="Permalink to this headline">¶</a></h1>
<p>В моей практике было три случая, когда в Storm ORM требовалось &#8220;допиливать&#8221; то, что SQLAlchemy (или ее сообщество) предоставляет в готовом виде.</p>
<ol class="arabic simple">
<li><a class="reference external" href="http://docs.sqlalchemy.org/en/rel_1_1/orm/session_api.html#sqlalchemy.orm.session.Session.bulk_save_objects">Массовая вставка объектов</a>, причем, с условием ON DUPLICATE KEY UPDATE.</li>
<li>Адаптация <a class="reference external" href="https://github.com/mitsuhiko/sqlalchemy-django-query">SQL Builder под интерфейс django.db.models.query.QuerySet</a>.</li>
<li>Поддержка паттерна <a class="reference external" href="http://docs.sqlalchemy.org/en/rel_1_1/orm/extensions/declarative/inheritance.html#concrete-table-inheritance">Concrete Table Inheritance</a></li>
</ol>
<p>В Storm ORM <a class="reference external" href="https://bugs.launchpad.net/storm/+bug/1412845">нет блокировки потоков</a> при ленивой модификации критически важных глобальных метаданных.
Это не проблема, и легко решается (достаточно исполнить их сразу, под блокировкой).
Но об этом нужно знать, иначе в условиях высоко-конкурентных потоков можно завалить прод.</p>
<p>Расширять функциональность Storm ORM все-таки придется.
Возможности SQL-билдера нужно расширять.
Утилита prefetch_related() для OneToMany() тоже не помешала бы.
Возможно, понадобится реализовать каскадное удаление средствами ORM, а не базы данных.
И добавить сериализатор объектов.
Storm ORM не реализует топологическую сортировку, но позволяет ее легко реализовать.</p>
<p>То что класс Store (по сути паттерн Repository) совмещает в себе обязанности маппера, не очень удобно.
Например, это создает проблему в реализации паттерна <a class="reference external" href="http://martinfowler.com/eaaCatalog/classTableInheritance.html">Class Table Inheritance</a>.
Сами разработчики Storm ORM советуют <a class="reference external" href="https://storm.canonical.com/Infoheritance">заменить наследование композицией</a> (впрочем, postgresql сам <a class="reference external" href="http://www.postgresql.org/docs/9.4/static/tutorial-inheritance.html">поддерживает наследование</a> (<a class="reference external" href="http://www.postgresql.org/docs/9.4/static/ddl-inherit.html">DDL</a>)).
Отсутствие выделенного класса для маппера вынуждает также загромождать доменную модель <a class="reference external" href="https://storm.canonical.com/Manual#A__storm_pre_flush__">служебной логикой</a>.</p>
</div>
<div class="section" id="storm-orm-ambiguities-ru">
<span id="id8"></span><h1><a class="toc-backref" href="#id45">О неоднозначном</a><a class="headerlink" href="#storm-orm-ambiguities-ru" title="Permalink to this headline">¶</a></h1>
<p>Поддержка ACID и двухфазных транзакций привела к тому, что доменная модель на самом деле не является чистой.
Тем не менее, она имеет чистый интерфейс, и ведет себя как обычный чистый объект.
На самом деле инстанция модели не содержит данных, а ссылается на структуру данных посредством дескрипторов.
Реализовать все это (тем более в стиле KISS), является титаническим трудом.
Хотя я не уверен, что сама реализация такого сложного механизма соответствует принципу KISS.
Быть может, простота реализации здесь была бы предпочтительней, нежели простота интерфейса.
И тем не менее, это делает одним аргументом против ORM меньше.</p>
<p>Кроме того, это решение не обеспечивает полной согласованности поведения доступного для использования.
Предположим, вы создали два новых объекта, первый из которых ссылается на второй по внешнему ключу.
Вы связали эти два объекта посредством дескриптора.
В момент (отложенного) сохранения, когда второму объекту будет присвоен первичный ключ, значение внешнего ключа первого объекта автоматически примет нужное значение.
Но еще до момента сохранения Вы можете получить доступ к второму объекту посредством обращения к связи первого объекта (благодаря дескрипторам объект будет доступен, см. <a class="reference external" href="https://storm.canonical.com/Tutorial#References_and_subclassing">пример</a>).
Тем не менее, вы не имеете возможности запросить напрямую второй объект у хранилища Store() до момента сохранения.</p>
</div>
<div class="section" id="faq">
<span id="storm-orm-faq-ru"></span><h1><a class="toc-backref" href="#id46">FAQ</a><a class="headerlink" href="#faq" title="Permalink to this headline">¶</a></h1>
<p><em>q: Storm ORM не поддерживает Python3.</em></p>
<p>a: Если Вы мигрировали хотя бы одну библиотеку на Python3, то понимаете, что этот процесс больших трудностей не вызывает.
95% работы делает команда <code class="docutils literal"><span class="pre">2to3</span></code>.
Единственный вопрос, который может иметь значение, - это миграция Си-расширения.
Впрочем, даже без него Storm ORM работает достаточно быстро, и не сильно теряет в производительности.
Найти Си-расширение под Python3 можно <a class="reference external" href="http://bazaar.launchpad.net/~martin-v/storm/storm3k/view/head:/storm/cextensions.c">здесь</a> (<a class="reference external" href="http://bazaar.launchpad.net/~martin-v/storm/storm3k/revision/438">diff</a>).
Есть еще один <a class="reference external" href="https://code.launchpad.net/~hackedbellini/storm/py3">py3 branch</a>.</p>
<p><em>q: Как использовать Storm ORM с фрагментами Raw-SQL</em></p>
<p>a: Вообще-то так лучше не делать. Лучше расширить SQL-builder. Но если очень надо:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">storm.expr</span> <span class="k">import</span> <span class="n">SQL</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">authors.models</span> <span class="k">import</span> <span class="n">Author</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">store</span> <span class="o">=</span> <span class="n">get_my_store</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">store</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">Author</span><span class="p">,</span> <span class="n">SQL</span><span class="p">(</span><span class="s2">&quot;auth_user.id = </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,),</span> <span class="n">Author</span><span class="p">)))</span>
<span class="go">[&lt;authors.models.Author object at 0x7fcd64cea750&gt;]</span>
</pre></div>
</div>
<p><em>q: Как использовать Storm ORM с полностью чистым SQL, чтобы результат запроса содержал инстанции моделей?</em></p>
<p>a: Поскольку Storm ORM использует паттерны Data Mapper, Identity Map и Unit of Work, мы должны указать в выборке все поля модели, и использовать для загрузки метод <code class="docutils literal"><span class="pre">Store._load_object()</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">store</span> <span class="o">=</span> <span class="n">get_my_store</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">storm.info</span> <span class="k">import</span> <span class="n">get_cls_info</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">authors.models</span> <span class="k">import</span> <span class="n">Author</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">author_info</span> <span class="o">=</span> <span class="n">get_cls_info</span><span class="p">(</span><span class="n">Author</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Load single object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">store</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT &quot;</span> <span class="o">+</span> <span class="n">store</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">author_info</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; FROM author where id = </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">store</span><span class="o">.</span><span class="n">_load_object</span><span class="p">(</span><span class="n">author_info</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">get_one</span><span class="p">())</span>
<span class="go">&lt;authors.models.Author at 0x7fcc76a85090&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Load collection of objects</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">store</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT &quot;</span> <span class="o">+</span> <span class="n">store</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">author_info</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; FROM author where id IN (</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">store</span><span class="o">.</span><span class="n">_load_object</span><span class="p">(</span><span class="n">author_info</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">get_all</span><span class="p">()]</span>
<span class="go">[&lt;authors.models.Author at 0x7fcc76a85090&gt;,</span>
<span class="go"> &lt;authors.models.Author at 0x7fcc76a854d0&gt;]</span>
</pre></div>
</div>
</div>
<div class="section" id="why-orm-ru">
<span id="id9"></span><h1><a class="toc-backref" href="#id47">А нужен ли вообще ORM?</a><a class="headerlink" href="#why-orm-ru" title="Permalink to this headline">¶</a></h1>
<p>Честно говоря, нет необходимости использовать ОРМ всегда и везде.
Во многих случаях (например, если от приложения требуется просто выдать список JSON значений) вполне достаточно простейшего <a class="reference external" href="http://martinfowler.com/eaaCatalog/tableDataGateway.html">Table Data Gateway</a>, который будет возвращать простейшие значения <a class="reference external" href="http://martinfowler.com/eaaCatalog/dataTransferObject.html">Data Transfer Object</a>.
Тут уже дело личных предпочтений.</p>
<div class="section" id="query-object">
<span id="why-query-object-ru"></span><h2><a class="toc-backref" href="#id48">Нужен ли Query Object?</a><a class="headerlink" href="#query-object" title="Permalink to this headline">¶</a></h2>
<p>Единственное в чем я убежден твердо, - это в том, что без паттерна <a class="reference external" href="http://martinfowler.com/eaaCatalog/queryObject.html">Query Object</a> (часто именуемом как SQLBuilder) обойтись довольно трудно, если не невозможно.</p>
<p>1. Даже самые стойкие сторонники концепции &#8220;чистого SQL&#8221; достаточно быстро сталкиваются с невозможностью выразить SQL-запрос в чистом виде, и вынуждены его динамически составлять в зависимости от условий.
А это уже разновидность концепции SQLBuilder, пусть и в примитивном виде, и реализованном в частном порядке.
А решения частного порядка всегда занимают много места, так как отступают от принципа <a class="reference external" href="https://en.wikipedia.org/wiki/Don't_repeat_yourself">DRY</a>.</p>
<p>Проиллюстрирую это примером.
Имеем запрос на выборку объявлений из БД по 5-ти критериям.
Нужно позволить пользователям выбирать объявления по совокупности любого количества из перечисленных критериев:</p>
<ol class="arabic simple" start="0">
<li>Без критериев.</li>
<li>Типу объявления.</li>
<li>Стране, области, городу.</li>
<li>По категориям, включая вложенные категории.</li>
<li>По пользователям (все объявления одного пользователя)</li>
<li>По поисковым словам.</li>
</ol>
<p>Итого, пришлось бы заготовить 2^5 = 32 фиксированных SQL-запроса, и это если не учитывать вложенностей древовидных структур (иначе п.3 пришлось бы разнести на еще 3 пункта, так как нередко эти данные хранятся денормализованно).</p>
<p>Список возможных комбинаций критериев:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mi">0</span>
<span class="mi">1</span>
<span class="mi">1</span><span class="p">,</span><span class="mi">2</span>
<span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span>
<span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span>
<span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span>
<span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span>
<span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span>
<span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span>
<span class="mi">1</span><span class="p">,</span><span class="mi">3</span>
<span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span>
<span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span>
<span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span>
<span class="mi">1</span><span class="p">,</span><span class="mi">4</span>
<span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span>
<span class="mi">1</span><span class="p">,</span><span class="mi">5</span>
<span class="mi">2</span><span class="p">,</span>
<span class="mi">2</span><span class="p">,</span><span class="mi">3</span>
<span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span>
<span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span>
<span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span>
<span class="mi">2</span><span class="p">,</span><span class="mi">4</span>
<span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span>
<span class="mi">2</span><span class="p">,</span><span class="mi">5</span>
<span class="mi">3</span>
<span class="mi">3</span><span class="p">,</span><span class="mi">4</span>
<span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span>
<span class="mi">3</span><span class="p">,</span><span class="mi">5</span>
<span class="mi">4</span>
<span class="mi">4</span><span class="p">,</span><span class="mi">5</span>
<span class="mi">5</span>
</pre></div>
</div>
<p>А если добавить еще один критерий, - это будет 2^6=64 комбинации, т.е. в 2 раза больше.
Еще один, - это будет 2^7=128 комбинаций.</p>
<p>128 фиксированных запросов вынуждают отказаться от концепции &#8220;чистого SQL&#8221; в пользу концепции &#8220;динамического построения SQL-запроса&#8221;.
Метод, создающий такой запрос, будет принимать много аргументов, что отразится на чистоте кода.
Можно разделить ответственности, чтобы каждый метод строил свою часть запроса.
Но во-первых, такой подход создаст SQL-билдер в частном порядке (отступление от принципа <a class="reference external" href="https://en.wikipedia.org/wiki/Don't_repeat_yourself">DRY</a>).
А во-вторых, если продолжить полученные методы &#8220;вычищать&#8221;, освобождать от зависимостей и повышать <a class="reference external" href="https://en.wikipedia.org/wiki/Cohesion_%28computer_science%29">связанность</a> классов, - то мы в конечном итоге прийдем к классам Criteria и реализуем паттерн <a class="reference external" href="http://martinfowler.com/eaaCatalog/queryObject.html">Query Object</a>.
Повторюсь, попытки разбить этот метод приведут к падению <a class="reference external" href="https://en.wikipedia.org/wiki/Cohesion_%28computer_science%29">связанности</a> класса.
Восстановление связанности выделит классы Criteria.</p>
<p>Т.е. фактически создадим SQL-билдер, который может быть выделен в отдельную утилиту, которая сможет развиваться отдельно.</p>
<p>А если же мы не будем &#8220;вычищать&#8221; полученные методы, освобождать от зависимостей и повышать связанность классов, то получим нечитаемое мессиво с кучей SQL-кусочков разбросанных по разным методам.
Иногда такие &#8220;кусочки&#8221; оформляют в виде статических методов класса, что обретает признаки &#8220;G18: Inappropriate Static&#8221; <a class="footnote-reference" href="#fncc" id="id10">[1]</a>, и в полном соответствии с рекомендациями Robert C. Martin напрашивается полиморфный объект <a class="reference external" href="http://martinfowler.com/eaaCatalog/queryObject.html">Criteria</a>.
В любом случае, читаемость &#8220;чистого SQL&#8221; (а это один из самых весомых аргументов в его пользу) будет утрачена (она будет даже ниже, чем читаемость SQL-билдера).</p>
<p>Иными словами, SQL-билдеры потому и существуют, что они являются вершиной реализации <a class="reference external" href="https://en.wikipedia.org/wiki/Single_responsibility_principle">Single responsibility principle</a> (SRP) в данном случае.
В главе &#8220;Chapter 10: Classes. Organizing for Change&#8221; известной книги  «Clean Code: A Handbook of Agile Software Craftsmanship» <a class="footnote-reference" href="#fncc" id="id11">[1]</a>, C.Martin демонстрирует достижение принципа <a class="reference external" href="https://en.wikipedia.org/wiki/Single_responsibility_principle">SRP</a> именно на примере SQL-билдера.</p>
<p>Подобно объектам-гибридам, сочетающим в себе недостатки структур данных и объектов, SQL-билдеры реализованные в частном порядке вбирают в себя недостатки обоих концепций.
Они не обладают ни читаемостью Raw-SQL, ни удобством полноценных SQL-билдеров.
Это вынуждает или отказаться от динамического построения вообще, в пользу читаемости кода, или уже довести уровни абстракции до полноценного SQL-билдера.</p>
<p>Также концепция &#8220;чистого SQL&#8221; практически неосуществима в реализации следующих паттернов и подходов:</p>
<ul class="simple">
<li>Динамически изменяемая сортировка</li>
<li>Мультиязычность посредством суффиксирования полей</li>
<li><a class="reference external" href="http://martinfowler.com/eaaCatalog/concreteTableInheritance.html">Concrete Table Inheritance</a></li>
<li><a class="reference external" href="http://martinfowler.com/eaaCatalog/classTableInheritance.html">Class Table Inheritance</a></li>
<li><a class="reference external" href="https://en.wikipedia.org/wiki/Entity%E2%80%93attribute%E2%80%93value_model">Entity Attribute Value</a></li>
<li>и т.д.</li>
</ul>
<p>2. Такие запросы невозможно наследовать без <a class="reference external" href="https://pypi.python.org/pypi/sqlparse">синтаксического анализа</a> (например, чтобы просто изменить сортировку), что обычно влечет за собой их полное копирование.
А каждую копию приходится сопровождать отдельно, что усложняет сопровождение такого кода.
Впрочем, на досуге я написал простейший <a class="reference external" href="http://sqlbuilder.readthedocs.io/en/latest/#short-manual-for-sqlbuilder-mini">mini-builder, который представляет SQL-запрос в виде многоуровневого списка с фрагментами Raw-SQL</a>, что позволяет полноценно выстраивать условно-составные SQL-запросы и при этом практически полностью сохраняет читаемость Raw-SQL.</p>
<p>3. Мне нередко приходилось видеть среди файлов с Raw-SQL диффы на несколько сотен строк только потому, что в модель был добавлен новый атрибут, что имеет признаки &#8220;Divergent Change&#8221; <a class="footnote-reference" href="#fnr" id="id12">[2]</a> и &#8220;Shotgun Surgery&#8221; <a class="footnote-reference" href="#fnr" id="id13">[2]</a>.
Это потому, что SQL-запросы содержат много дубликатов выражений.
SQL-код, даже если он в Python-файлах, все равно остается кодом.
И к нему также справедливо правило &#8220;G5: Duplication&#8221; <a class="footnote-reference" href="#fncc" id="id14">[1]</a> (&#8220;Duplicated Code&#8221; <a class="footnote-reference" href="#fnr" id="id15">[2]</a>).
В случае использования SQLBuilder таких проблем не возникает, так как необходимые метаданные для построения запроса (в частности, список выбираемых полей) хранятся в едином месте.</p>
<p>4. При использовании концепции &#8220;чистого SQL&#8221;, критерии выборки обычно передаются  в методы выборки в виде аргументов, из-за чего нередко приходится изменять их интерфейсы (а также добавлять новые методы), когда добавляются новые поля данных и критерии выборки к ним, что нарушает <a class="reference external" href="https://en.wikipedia.org/wiki/Open/closed_principle">Open/Closed Principle</a> и имеет признаки &#8220;Divergent Change&#8221; <a class="footnote-reference" href="#fnr" id="id16">[2]</a> и &#8220;Shotgun Surgery&#8221; <a class="footnote-reference" href="#fnr" id="id17">[2]</a>.</p>
<p>Напрашивается &#8220;<a class="reference external" href="http://www.refactoring.com/catalog/introduceParameterObject">Introduce Parameter Object</a>&#8221; <a class="footnote-reference" href="#fnr" id="id18">[2]</a> с выделением класса Criteria паттерна <a class="reference external" href="http://martinfowler.com/eaaCatalog/queryObject.html">Query Object</a>.
Этот подход исключит подобные проблемы, поскольку все критерии выборки инкапсулированы в единственном объекте (<a class="reference external" href="https://en.wikipedia.org/wiki/Composite_pattern">Composite pattern</a>), а также освободит методы выборки от условных операторов &#8220;<a class="reference external" href="http://www.refactoring.com/catalog/replaceConditionalWithPolymorphism.html">Replace Conditional with Polymorphism</a>&#8221; <a class="footnote-reference" href="#fnr" id="id19">[2]</a>.</p>
<p>В своем воображении (и в программном коде) человек оперирует объектами.
Способ сортировки и ее направление - характеризуют состояние объекта.
Критерии выборки - это тоже объекты, от которых мы ожидаем определенного поведения (образовывать композиции, влиять на выборку БД).
Когда объекты есть, но они не выражены в коде, программа теряет способность выражать замысел разработчика (&#8220;G16: Obscured Intent&#8221; <a class="footnote-reference" href="#fncc" id="id20">[1]</a>).</p>
<p>5. Если какое-то значение объекта требует особой конвертации в DB представление, - нам придется загромождать код явным вызовом этих конвертаций.</p>
<p>6. Существует тенденция (которая мне регулярно встречается) использования паттерна <a class="reference external" href="http://martinfowler.com/eaaCatalog/repository.html">Repository</a> в сочетании с Raw-SQL.
Поскольку сам Repository предназначен для сокрытия источника данных, то непонятно, как передавать в Repository критерии выборки, чтобы они были полностью абстрактны от источника данных, т.е. абстрактны от Raw-SQL.</p>
<p>В примитивных случаях, это, конечно, не проблема (можно передавать их именованными аргументами функции, хотя это, в свою очередь, вызывает проблемы описанные в п.4).</p>
<p>Но если требуется хотя бы пять нефиксированных, взаимозависимых или составных критериев (сочетающих вложенные приоритизированные операции &#8220;OR&#8221;, &#8220;AND&#8221;, логический &#8220;XOR&#8221; и др.), то это уже проблема, решение которой и входит в обязанности паттерна Query Object.
Передача же фрагментов SQL строк в качестве аргументов функции имеет признаки &#8220;G6: Code at Wrong Level of Abstraction&#8221; <a class="footnote-reference" href="#fncc" id="id21">[1]</a> и  &#8220;G34: Functions Should Descend Only One Level of Abstraction&#8221; <a class="footnote-reference" href="#fncc" id="id22">[1]</a>.</p>
<p>7. Нередко для условного составления запроса используется форматирование строк. Проблема в том, что тот объект, который хочет использовать этот запрос в модифицированной форме, должен быть осведомлен о деталях реализации механизма его модификации.
Возникает логическая зависимость, нарушается инкапсуляция.</p>
<p>Чтобы этого избежать, обычно объект, форматирующий запрос, наделяется методами, которые модифицируют запрос под потребности использующих его объектов.
Получается Божественный Объект, который должен знать о потребностях всех объектов, которые потенциально могут его использовать.</p>
<p>Это нарушает OCP и приводит к &#8220;Divergent Change&#8221; <a class="footnote-reference" href="#fnr" id="id23">[2]</a> и &#8220;Shotgun Surgery&#8221; <a class="footnote-reference" href="#fnr" id="id24">[2]</a>. Нередко остается мусор в виде невостребованных методов, после удаления использующих их объектов.
Очень большие классы обычно разбиваются наследованием или композицией.
Это приводит к тому, что получить целостное представление о том, что делает метод, невозможно без неоднократного прерывания взгляда на изучение содержимого различных методов, классов, а то и файлов.</p>
<p>Паттерн Query Object предоставляет унифицированный интерфейс модификации запроса, освобождая объект запроса от необходимости знать о потребностях окружающих объектов.</p>
<p>8. Отдельно хочу затронуть вопрос использования синтаксических конструкций языка для построения SQL-запросов.</p>
<p>Вот несколько примеров:</p>
<ul class="simple">
<li><a class="reference external" href="https://github.com/pythonql/pythonql">A Query Language extension for Python</a>: Query files, objects, SQL and NoSQL databases with a built-in query language</li>
<li><a class="reference external" href="https://bitbucket.org/robertodealmeida/simpleql/">simpleql</a> SQL table using nothing but Python to build the query</li>
<li><a class="reference external" href="http://code.activestate.com/recipes/442447/">Generator expressions</a> for database requests (Python recipe)</li>
</ul>
<p>Я скажу субъективно, мне больше нравится использовать для этого объекты.
Более того, мне нравится когда сами синтаксические конструкции языка представлены объектами, как в Smalltalk.</p>
</div>
<div class="section" id="data-mapper">
<span id="why-datamapper-ru"></span><h2><a class="toc-backref" href="#id49">Нужен ли сам Data Mapper?</a><a class="headerlink" href="#data-mapper" title="Permalink to this headline">¶</a></h2>
<p>Что же касается самого маппера, то тут следует решить, нужна ли приложению <a class="reference external" href="http://martinfowler.com/eaaCatalog/domainModel.html">Domain Model</a>, или вполне устроит паттерн <a class="reference external" href="http://martinfowler.com/eaaCatalog/transactionScript.html">Transaction Script</a>.
Я не буду останавливаться на этом выборе, так как он хорошо освещен в «Patterns of Enterprise Application Architecture» <a class="footnote-reference" href="#fnpoeaa" id="id25">[3]</a>.
Но если нуждам приложения больше соответствует Domain Model, то без полноценного ORM (пусть и самодельного) обойтись будет непросто, по крайней мере, для качественной, удобной и быстрой работы.</p>
<p>По поводу распространенных аргументов против ORM.
Я не буду затрагивать уже пронафталиненные темы вроде того, что базы данных не поддерживают наследования.</p>
<p>Во-первых, <a class="reference external" href="http://www.postgresql.org/docs/9.4/static/tutorial-inheritance.html">поддерживают</a> (<a class="reference external" href="http://www.postgresql.org/docs/9.4/static/ddl-inherit.html">DDL</a>).</p>
<p>Во-вторых, наследование можно заменить композицией. Кстати, полезность наследования в ООП до сих пор является <a class="reference external" href="http://www.javaworld.com/article/2073649/core-java/why-extends-is-evil.html">обсуждаемым вопросом</a>. В Go-lang наследование отсутствует в пользу композиции.
Сами языки программирования реализуют наследование посредством композиции.</p>
<p>В-третьих, сегодня только ленивый не знает о паттернах
<a class="reference external" href="http://martinfowler.com/eaaCatalog/singleTableInheritance.html">Single Table Inheritance</a>,
<a class="reference external" href="http://martinfowler.com/eaaCatalog/concreteTableInheritance.html">Concrete Table Inheritance</a>,
<a class="reference external" href="http://martinfowler.com/eaaCatalog/classTableInheritance.html">Class Table Inheritance</a> и
<a class="reference external" href="https://en.wikipedia.org/wiki/Entity%E2%80%93attribute%E2%80%93value_model">Entity Attribute Value</a>.</p>
<p>Поэтому я затрону только два существенных на мой взгляд вопроса:</p>
<ol class="arabic simple">
<li>Представлять данные в памяти объектами, или структурами данных?</li>
<li>ACID и Two-phase transaction, согласованность объекта в памяти и его данными на диске.</li>
</ol>
<p>По поводу первого вопроса у меня нет однозначного мнения.
Мы живем в мире объектов, и именно поэтому появилось объектно-ориентированное программирование.
Человеку проще мыслить объектами.
В Python даже элементарные типы являются полноценными объектами, с методами, наследованием и т.п.</p>
<p>В чем отличие между структурой данных и объектом? В Python это отличие сугубо условное.
Объекты используют представление данных на абстрактном уровне.</p>
<blockquote>
<div>&#8220;Объекты скрывают свои данные за абстракциями и предоставляют функции, работающие с этими данными. Структуры данных раскрывают свои данные и не имеют осмысленных функций.&#8221;
&#8220;Objects hide their data behind abstractions and expose functions that operate on that data. Data structure expose their data and have no meaningful functions.&#8221;
(«Clean Code: A Handbook of Agile Software Craftsmanship» <a class="footnote-reference" href="#fncc" id="id26">[1]</a>)</div></blockquote>
<p>Тут мы снова упираемся в вопрос Domain Model vs Transaction Script, поскольку доменная модель по своему определению охватывает поведение (функции) и свойства (данные).</p>
<p>Но есть еще один немаловажный момент.
Допустим, мы храним в БД две колонки - цена и валюта.
Или, например, данные полиморфной связи - тип объекта и его идентификатор.
Или координаты - x и y.
Или путь древовидной структуры - страна, область, город, улица.
Т.е. несколько данных образуют единую сущность, и изменение части этих данных не имеет никакого смысла.
Как задать политику доступа данных и гарантировать атомарность их изменения (кроме как использованием объектов или неизменяемых типов)?</p>
<p>Я думаю, что мы должны думать прежде всего о бизнес-задачах.
О том, какими объектами и как должна оперировать программа.
Вопросы реализации не должны диктовать бизнес-логику.
Вопросы хранения информации должны удовлетворять нашим требованиям, а не указывать нам требования.
Если бы это было не так, то объектно-ориентированное программирование до сих пор не возникло бы.</p>
<blockquote>
<div><p>&#8220;Весь смысл объектов в том, что они позволяют хранить данные вместе с процедурами их обработки.
Классический пример дурного запаха – метод, который больше интересуется не тем классом, в котором он находится, а каким то другим.
Чаще всего предметом зависти являются данные.&#8221;</p>
<p>&#8220;The whole point of objects is that they are a technique to package data with the processes used
on that data. A classic smell is a method that seems more interested in a class other than the one
it actually is in. The most common focus of the envy is the data.&#8221;
(«Refactoring: Improving the Design of Existing Code» <a class="footnote-reference" href="#fnr" id="id27">[2]</a>)</p>
</div></blockquote>
<blockquote>
<div>&#8220;Now this design has some problems. Most important, the details of the table structure have leaked
into the DOMAIN LAYER ; they should be isolated in a mapping layer that relates the domain objects
to the relational tables. Implicitly duplicating that information here could hurt the modifiability and
maintainability of the Invoice and Customer objects, because any change to their mappings now
have to be tracked in more than one place. But this example is a simple illustration of how to keep
the rule in just one place. Some object-relational mapping frameworks provide the means to
express such a query in terms of the model objects and attributes, generating the actual SQL in
the infrastructure layer. This would let us have our cake and eat it too.&#8221;
(«Domain-Driven Design: Tackling Complexity in the Heart of Software» <a class="footnote-reference" href="#fnddd" id="id28">[4]</a>)</div></blockquote>
<blockquote>
<div>The greatest value I&#8217;ve seen delivered has been when a narrowly scoped framework automates a
particularly tedious and error-prone aspect of the design, such as persistence and object-relational
mapping. The best of these unburden developers of drudge work while leaving them complete
freedom to design.
(«Domain-Driven Design: Tackling Complexity in the Heart of Software» <a class="footnote-reference" href="#fnddd" id="id29">[4]</a>)</div></blockquote>
<p>Одним из главных принципов объектно ориентированного программирования является инкапсуляция.
Принцип единой обязанности гласит, что каждый объект должен иметь одну обязанность и эта обязанность должна быть полностью инкапсулирована в класс.
Лишая объект поведения, мы возлагаем его поведение на другой объект, который должен обслуживать первый.
Вопрос в том, оправдано ли это?
Если в разделении Active Record на Data Mapper и Domain Model это очевидно, и направлено именно на соблюдение принципа единой обязанности, то в данном случае ответ не так очевиден.
Объект поведения начинает &#8220;завидовать&#8221; объекту данных &#8220;G14: Feature Envy&#8221; <a class="footnote-reference" href="#fncc" id="id30">[1]</a>, (&#8220;Feature Envy&#8221; <a class="footnote-reference" href="#fnr" id="id31">[2]</a>), обретая признаки &#8220;F2: Output Arguments&#8221; <a class="footnote-reference" href="#fncc" id="id32">[1]</a>, &#8220;Convert Procedural Design to Objects&#8221; <a class="footnote-reference" href="#fnr" id="id33">[2]</a>,  &#8220;Primitive Obsession&#8221; <a class="footnote-reference" href="#fnr" id="id34">[2]</a> и &#8220;Data Class&#8221; <a class="footnote-reference" href="#fnr" id="id35">[2]</a>.</p>
<p>Рассуждения M.Fowler по этому поводу в статье &#8220;<a class="reference external" href="http://www.martinfowler.com/bliki/AnemicDomainModel.html">Anemic Domain Model</a>&#8221;.</p>
<blockquote>
<div><p>&#8220;Многочисленность классов и методов иногда является результатом бессмысленного догматизма. В качестве примера можно привести стандарт кодирования, который требует создания интерфейса для каждого без исключения класса. Или разработчиков, настаивающих, что поля данных и поведение всегда должны быть разделены на классы данных и классы поведения. Избегайте подобных догм, а в своей работе руководствуйтесь более прагматичным подходом.&#8221;</p>
<p>&#8220;High class and method counts are sometimes the result of pointless dogmatism. Consider, for example, a coding standard that insists on creating an interface for each and every class. Or consider developers who insist that fields and behavior must always be separated into data classes and behavior classes. Such dogma should be resisted and a more pragmatic approach adopted.&#8221;
(«Clean Code: A Handbook of Agile Software Craftsmanship» <a class="footnote-reference" href="#fncc" id="id36">[1]</a>)</p>
</div></blockquote>
<blockquote>
<div><p>&#8220;Если требования архитектурной среды к распределению обязанностей таковы, что элементы, реализующие концептуальные объекты, оказываются физически разделенными, то код больше не выражает модель.</p>
<p>Нельзя разделять до бесконечности, у человеческого ума есть свои пределы, до которых он еще способен соединять разделенное;
если среда выходит ха это пределы, разработчики предметной области теряют способность расчленять модель на осмысленные фрагменты.&#8221;</p>
<p>&#8220;If the framework&#8217;s partitioning conventions pull apart the elements implementing the
conceptual objects, the code no longer reveals the model.</p>
<p>There is only so much partitioning a mind can stitch back together, and if the framework uses
it all up, the domain developers lose their ability to chunk the model into meaningful pieces.&#8221;
(«Domain-Driven Design: Tackling Complexity in the Heart of Software» <a class="footnote-reference" href="#fnddd" id="id37">[4]</a>)</p>
</div></blockquote>
<p>По поводу второго вопроса.
Из всех ORM, что я встречал в своей практике (не только на Python), поддержка ACID и Two-phase transaction в Storm ORM и SQLAlchemy реализована наилучшим образом.
Надо сказать, в подавляющем большинстве существующих ORM такие попытки даже не предпринимаются.</p>
<p>Рассуждения Мартина Фаулера на этот счет в статье &#8220;<a class="reference external" href="http://martinfowler.com/bliki/OrmHate.html">Orm Hate</a>&#8221;.</p>
<p>Статья Роберта Мартина &#8220;<a class="reference external" href="https://8thlight.com/blog/uncle-bob/2013/10/01/Dance-You-Imps.html">Dance you Imps!</a>&#8221;.</p>
<p>В целом у меня отношение к ORM неоднозначное.
Я часто использую в сыром виде паттерн <a class="reference external" href="http://martinfowler.com/eaaCatalog/dataMapper.html">DataMapper</a> для сложных запросов с аннотациями и агрегациями (особенно в Django-приложениях), но также часто использую ORM.
Слишком много существующих ORM создает больше &#8220;запахов&#8221; в коде, чем устраняет.
Но Storm ORM к ним не относится.</p>
<p>Интервью с Gustavo Niemeyer, ведущим разработчиком проекта Storm компании Canonical &#8220;<a class="reference external" href="http://www.drdobbs.com/storm-an-orm-for-python/201000460">Storm: An ORM for Python</a>&#8221;.</p>
</div>
</div>
<div class="section" id="id38">
<h1><a class="toc-backref" href="#id50">Послесловие</a><a class="headerlink" href="#id38" title="Permalink to this headline">¶</a></h1>
<p>Storm ORM - это инструмент для высококвалифицированных специалистов которые понимают его превосходства и не боятся сопровождать 300 Кб высококачественного кода самостоятельно.</p>
<p>This article in English &#8220;<a class="reference internal" href="../../en/storm-orm/"><span class="doc">Why I prefer Storm ORM for Python</span></a>&#8221;.</p>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="fncc" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id4">1</a>, <a class="fn-backref" href="#id5">2</a>, <a class="fn-backref" href="#id10">3</a>, <a class="fn-backref" href="#id11">4</a>, <a class="fn-backref" href="#id14">5</a>, <a class="fn-backref" href="#id20">6</a>, <a class="fn-backref" href="#id21">7</a>, <a class="fn-backref" href="#id22">8</a>, <a class="fn-backref" href="#id26">9</a>, <a class="fn-backref" href="#id30">10</a>, <a class="fn-backref" href="#id32">11</a>, <a class="fn-backref" href="#id36">12</a>)</em> «<a class="reference external" href="http://www.informit.com/store/clean-code-a-handbook-of-agile-software-craftsmanship-9780132350884">Clean Code: A Handbook of Agile Software Craftsmanship</a>» <a class="reference external" href="http://informit.com/martinseries">Robert C. Martin</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="fnr" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id12">1</a>, <a class="fn-backref" href="#id13">2</a>, <a class="fn-backref" href="#id15">3</a>, <a class="fn-backref" href="#id16">4</a>, <a class="fn-backref" href="#id17">5</a>, <a class="fn-backref" href="#id18">6</a>, <a class="fn-backref" href="#id19">7</a>, <a class="fn-backref" href="#id23">8</a>, <a class="fn-backref" href="#id24">9</a>, <a class="fn-backref" href="#id27">10</a>, <a class="fn-backref" href="#id31">11</a>, <a class="fn-backref" href="#id33">12</a>, <a class="fn-backref" href="#id34">13</a>, <a class="fn-backref" href="#id35">14</a>)</em> «<a class="reference external" href="http://martinfowler.com/books/refactoring.html">Refactoring: Improving the Design of Existing Code</a>» by <a class="reference external" href="http://martinfowler.com/">Martin Fowler</a>, Kent Beck, John Brant, William Opdyke, Don Roberts</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="fnpoeaa" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id6">2</a>, <a class="fn-backref" href="#id25">3</a>)</em> «Patterns of Enterprise Application Architecture» by Martin Fowler, David Rice, Matthew Foemmel, Edward Hieatt, Robert Mee, Randy Stafford</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="fnddd" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[4]</td><td><em>(<a class="fn-backref" href="#id28">1</a>, <a class="fn-backref" href="#id29">2</a>, <a class="fn-backref" href="#id37">3</a>)</em> «Domain-Driven Design: Tackling Complexity in the Heart of Software» by Eric Evans</td></tr>
</tbody>
</table>
<div class="note update admonition">
<p class="first last admonition-title">Updated on Jul 31, 2017</p>
</div>
</div>

  <div class="section">
  
    


<div class="section">
  <span style="float: left;">
  
  
  <a href="../../en/storm-orm/">
    <i class="fa fa-arrow-circle-left"></i>
    Why I prefer Storm ORM for Python
  </a>
  
  </span>
  <span>&nbsp;</span>
  <span style="float: right;">
  
  
  <a href="../flag-arguments/">
    Аргументы-флаги
    <i class="fa fa-arrow-circle-right"></i>
  </a>
  </span>
  
</div>

  
  
    <div class="section">
    <h2>Comments</h2>
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'emacsway';
        var disqus_identifier = '/ru/storm-orm/';
        var disqus_title = 'Почему я выбираю Storm ORM для Python';
        var disqus_url = 'https://emacsway.github.io/ru/storm-orm/';

        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  
  </div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../">
    <img class="logo" src="../../_static/logo.jpg" alt="Logo"/>
    
    <h1 class="logo logo-name">@emacsway's blog</h1>
    
  </a>
</p>









  
  
  <h2>
  
  <i class="fa fa-calendar"></i>
    Oct 10, 2015
  
  </h2>

  <ul>
    
  <li><i class="fa fa-pencil-square-o"></i>
    Jul 31, 2017</li>
  

  
  <li><i class="fa-fw fa fa-user"></i>
    
      
      <a href="../../blog/author/ivan-zakrevsky/">Ivan Zakrevsky</a>
      
    </li>
  

  

  
  <li><i class="fa-fw fa fa-language"></i>
    
      
      <a href="../../blog/language/russian/">Russian</a>
      
    </li>
  

  

  
  <li><i class="fa-fw fa fa-tags"></i>
      
    
      
      <a href="../../blog/tag/orm/">ORM</a>,
      
    
      
      <a href="../../blog/tag/storm-orm/">Storm ORM</a>,
      
    
      
      <a href="../../blog/tag/datamapper/">DataMapper</a>,
      
    
      
      <a href="../../blog/tag/db/">DB</a>,
      
    
      
      <a href="../../blog/tag/sql/">SQL</a>,
      
    
      
      <a href="../../blog/tag/python/">Python</a>,
      
    
      
      <a href="../../blog/tag/django-model/">Django Model</a>
      
    </li>
  
  
  <li>
    <script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'emacsway'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function () {
    var s = document.createElement('script'); s.async = true;
    s.type = 'text/javascript';
    s.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
    </script>
    <i class="fa-fw fa fa-comments"></i>
    <a href="#disqus_thread" data-disqus-identifier="/ru/storm-orm/"> </a>
  </li>
  
  </ul>


<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../about/">About me</a></li>
</ul>


  <h3><a href="../../blog/">Recent Posts</a></h3>
  <ul>
    
    
      <li><a href="../about-quality-of-comments/">Aug 13 - О качестве комментариев в интернете</a></li>
    
      <li><a href="../javascript-and-repository-pattern/">Aug 06 - Реализация паттерна Repository в браузерном JavaScript</a></li>
    
      <li><a href="../django-framework/">Jul 26 - О моем опыте использования Django Framework</a></li>
    
      <li><a href="../../en/django-framework/">Jul 26 - About my experience of using Django Framework</a></li>
    
      <li><a href="../service-layer/">Jul 17 - Проектирование Сервисного Слоя</a></li>
    
  </ul>

  <h3><a href="../../blog/tag/">Tags</a></h3>
  <style type="text/css">
    ul.ablog-cloud {list-style: none; overflow: auto;}
    ul.ablog-cloud li {float: left; height: 20pt; line-height: 18pt; margin-right: 5px;}
    ul.ablog-cloud a {text-decoration: none; vertical-align: middle;}
    li.ablog-cloud-1{font-size: 80%;}
    li.ablog-cloud-2{font-size: 95%;}
    li.ablog-cloud-3{font-size: 110%;}
    li.ablog-cloud-4{font-size: 125%;}
    li.ablog-cloud-5{font-size: 140%;}
  </style>
  <ul class="ablog-cloud">
    
      
      <li class="ablog-cloud ablog-cloud-1">
        <a href="../../blog/tag/architecture/">Architecture</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-2">
        <a href="../../blog/tag/db/">DB</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-2">
        <a href="../../blog/tag/datamapper/">DataMapper</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-1">
        <a href="../../blog/tag/dependency-injection/">Dependency Injection</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-1">
        <a href="../../blog/tag/design/">Design</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-1">
        <a href="../../blog/tag/django/">Django</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-3">
        <a href="../../blog/tag/django-model/">Django Model</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-1">
        <a href="../../blog/tag/emacs/">Emacs</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-1">
        <a href="../../blog/tag/fowler/">Fowler</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-1">
        <a href="../../blog/tag/javascript/">JavaScript</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-4">
        <a href="../../blog/tag/orm/">ORM</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-5">
        <a href="../../blog/tag/python/">Python</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-1">
        <a href="../../blog/tag/repository/">Repository</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-2">
        <a href="../../blog/tag/sql/">SQL</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-2">
        <a href="../../blog/tag/storm-orm/">Storm ORM</a></li>
      
    
      
    
      
      <li class="ablog-cloud ablog-cloud-1">
        <a href="../../blog/tag/autocomplete/">autocomplete</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-1">
        <a href="../../blog/tag/cache/">cache</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-1">
        <a href="../../blog/tag/programming/">programming</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-1">
        <a href="../../blog/tag/refactoring/">refactoring</a></li>
      
    
  </ul>

  <h3><a href="../../blog/archive/">Archives</a></h3>
  <ul>
  
    
    <li><a href="../../blog/2017/">2017 (7)</a></li>
    
  
    
    <li><a href="../../blog/2016/">2016 (5)</a></li>
    
  
    
    <li><a href="../../blog/2015/">2015 (6)</a></li>
    
  
  </ul>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search/" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>

    <div class="footer">
      &copy;2017, Ivan Zakrevsky.
      
      |
      Powered by <a href="http://ablog.readthedocs.org/">ABlog</a> &amp; <a href="http://sphinx-doc.org/">Sphinx 1.4.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.8</a>
      
      |
      <a href="../../_sources/ru/storm-orm.txt"
          rel="nofollow">Page source</a>
    </div>

    

    


    

        <!-- Go to www.addthis.com/dashboard to customize your tools -->
        <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-597ba7fb5af2ef1e"></script>

    


<!-- google.com/analytics counter -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-69288289-1', 'auto');
  ga('send', 'pageview');

</script>
<!-- /google.com/analytics counter -->


<!-- Yandex.Metrika counter -->
<script type="text/javascript">
    (function (d, w, c) {
        (w[c] = w[c] || []).push(function() {
            try {
                w.yaCounter32948409 = new Ya.Metrika({
                    id:32948409,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true
                });
            } catch(e) { }
        });

        var n = d.getElementsByTagName("script")[0],
            s = d.createElement("script"),
            f = function () { n.parentNode.insertBefore(s, n); };
        s.type = "text/javascript";
        s.async = true;
        s.src = "https://mc.yandex.ru/metrika/watch.js";

        if (w.opera == "[object Opera]") {
            d.addEventListener("DOMContentLoaded", f, false);
        } else { f(); }
    })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/32948409" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->



  </body>
</html>