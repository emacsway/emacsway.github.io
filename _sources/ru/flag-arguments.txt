
Аргументы-флаги
===============

.. post:: Oct 22, 2015
   :language: ru
   :tags: Python, Programming, Software Construction
   :category:
   :author: Ivan Zakrevsky

В главе "Flag Arguments" известной книги «Clean Code. A Handbook of Agile Software Craftsmanship.», Robert C. Martin советует не использовать аргументов-флагов, справедливо замечая, что это свидетельствует о том, что функция делает более одной операции.

Но что если функция, например, атомарно создает неизменяемый объект? Если состояние объекта зависит от 5-ти флагов, то для того, чтобы разбить функцию на безфлаговые нам придется создать 2^5 = 32 фиксированные функции чтобы перебрать все возможные комбинации флагов.

Это приводит нас к одной из мотиваций паттерна "`Bridge <https://en.wikipedia.org/wiki/Bridge_pattern>`__" - устранению комбинаторного роста количества классов. Чтобы не создавать иерархию классов для каждой реализации (раздувая количество классов), применяется композиция вместо наследования. Иначе говоря, речь идет о `превосходстве композиции перед наследованием <http://www.javaworld.com/article/2073649/core-java/why-extends-is-evil.html>`__.

В данном случае, чтобы не создавать комбинаторного роста количества функций, могут быть использованы флаги.
Robert C. Martin эту тему не раскрыл, а жаль.

В качестве иллюстрации можно привести битовые маски флагов функций `re.search(pattern, string, flags=0) <https://docs.python.org/2/library/re.html#re.search>`__ или `open(name[, mode[, buffering]]) <https://docs.python.org/2/library/functions.html#open>`__. Только представьте себе, сколько понадобилось бы функций, чтобы выразить все возможные сочетания флагов.
